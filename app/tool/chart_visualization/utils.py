# utils.py
import sys
from io import StringIO


def extract_executable_code(code_str: str) -> str:
    """
    Extract executable code from function call's parameters

    Args:
        code_str (string): The python code generated by llm.

    Returns:
        String: Python code can execute directly.
    """
    lines = code_str.strip().splitlines()
    start_idx = -1
    end_idx = -1

    # Find first occurrence of ```
    for i, line in enumerate(lines):
        if "```" in line.strip() or '"""' in line.strip():
            start_idx = i
            break

    # Find last occurrence of ```
    for i in reversed(range(len(lines))):
        if "```" in line.strip() or '"""' in line.strip():
            end_idx = i
            break

    if start_idx != -1 and end_idx != -1 and start_idx < end_idx:
        lines = lines[start_idx + 1 : end_idx]
    elif start_idx != -1:
        lines = lines[start_idx + 1 :]
    elif end_idx != -1:
        lines = lines[:end_idx]

    return "\n".join(lines)


def run_code_in_thread(code_to_run: str, result: dict) -> None:
    """
    Executes the python code in sub-threading and update result

    Args:
        code_to_run (str): The Python code to execute.
        result (dict): Contains 'output' with execution output or error message and 'success' status.
    """
    try:
        safe_globals = {"__builtins__": dict(__builtins__)}
        output_buffer = StringIO()
        sys.stdout = output_buffer

        exec(code_to_run, safe_globals, {})

        sys.stdout = sys.__stdout__

        result["observation"] = output_buffer.getvalue()

    except Exception as e:
        result["observation"] = str(e)
        result["success"] = False
